
// This file was automatically derived from the JSON-RPC schemas in
// `doc/schemas`. Do not edit this file manually as it would get
// overwritten.

use std::convert::From;
#[allow(unused_imports)]
use cln_rpc::model::{responses,requests};
use crate::pb;

#[allow(unused_variables)]
impl From<&responses::GetinfoAddress> for pb::GetinfoAddress {
    fn from(c: &responses::GetinfoAddress) -> Self {
        Self {
            item_type: c.item_type as i32,
            port: c.port.into(),
            address: c.address.clone(),
        }
    }
}

#[allow(unused_variables)]
impl From<&responses::GetinfoBinding> for pb::GetinfoBinding {
    fn from(c: &responses::GetinfoBinding) -> Self {
        Self {
            item_type: c.item_type as i32,
            address: c.address.clone(),
            port: c.port.map(|v| v.into()),
            socket: c.socket.clone(),
        }
    }
}

#[allow(unused_variables)]
impl From<&responses::GetinfoResponse> for pb::GetinfoResponse {
    fn from(c: &responses::GetinfoResponse) -> Self {
        Self {
            id: hex::decode(&c.id).unwrap(),
            alias: c.alias.clone(),
            color: hex::decode(&c.color).unwrap(),
            num_peers: c.num_peers.clone(),
            num_pending_channels: c.num_pending_channels.clone(),
            num_active_channels: c.num_active_channels.clone(),
            num_inactive_channels: c.num_inactive_channels.clone(),
            version: c.version.clone(),
            lightning_dir: c.lightning_dir.clone(),
            blockheight: c.blockheight.clone(),
            network: c.network.clone(),
            fees_collected_msat: Some(c.fees_collected_msat.into()),
            address: c.address.iter().map(|s| s.into()).collect(),
            binding: c.binding.iter().map(|s| s.into()).collect(),
            warning_bitcoind_sync: c.warning_bitcoind_sync.clone(),
            warning_lightningd_sync: c.warning_lightningd_sync.clone(),
        }
    }
}

#[allow(unused_variables)]
impl From<&responses::ListfundsOutputs> for pb::ListfundsOutputs {
    fn from(c: &responses::ListfundsOutputs) -> Self {
        Self {
            txid: hex::decode(&c.txid).unwrap(),
            output: c.output.clone(),
            amount_msat: Some(c.amount_msat.into()),
            scriptpubkey: hex::decode(&c.scriptpubkey).unwrap(),
            address: c.address.clone(),
            redeemscript: c.redeemscript.as_ref().map(|v| hex::decode(&v).unwrap()),
            status: c.status as i32,
            blockheight: c.blockheight.clone(),
        }
    }
}

#[allow(unused_variables)]
impl From<&responses::ListfundsChannels> for pb::ListfundsChannels {
    fn from(c: &responses::ListfundsChannels) -> Self {
        Self {
            peer_id: hex::decode(&c.peer_id).unwrap(),
            our_amount_msat: Some(c.our_amount_msat.into()),
            amount_msat: Some(c.amount_msat.into()),
            funding_txid: hex::decode(&c.funding_txid).unwrap(),
            funding_output: c.funding_output.clone(),
            connected: c.connected.clone(),
            state: c.state as i32,
            short_channel_id: c.short_channel_id.clone(),
        }
    }
}

#[allow(unused_variables)]
impl From<&responses::ListfundsResponse> for pb::ListfundsResponse {
    fn from(c: &responses::ListfundsResponse) -> Self {
        Self {
            outputs: c.outputs.iter().map(|s| s.into()).collect(),
            channels: c.channels.iter().map(|s| s.into()).collect(),
        }
    }
}

#[allow(unused_variables)]
impl From<&responses::ListchannelsChannels> for pb::ListchannelsChannels {
    fn from(c: &responses::ListchannelsChannels) -> Self {
        Self {
            source: hex::decode(&c.source).unwrap(),
            destination: hex::decode(&c.destination).unwrap(),
            public: c.public.clone(),
            amount_msat: Some(c.amount_msat.into()),
            message_flags: c.message_flags.into(),
            channel_flags: c.channel_flags.into(),
            active: c.active.clone(),
            last_update: c.last_update.clone(),
            base_fee_millisatoshi: c.base_fee_millisatoshi.clone(),
            fee_per_millionth: c.fee_per_millionth.clone(),
            delay: c.delay.clone(),
            htlc_minimum_msat: Some(c.htlc_minimum_msat.into()),
            htlc_maximum_msat: c.htlc_maximum_msat.map(|f| f.into()),
            features: hex::decode(&c.features).unwrap(),
        }
    }
}

#[allow(unused_variables)]
impl From<&responses::ListchannelsResponse> for pb::ListchannelsResponse {
    fn from(c: &responses::ListchannelsResponse) -> Self {
        Self {
            channels: c.channels.iter().map(|s| s.into()).collect(),
        }
    }
}

#[allow(unused_variables)]
impl From<&responses::AddgossipResponse> for pb::AddgossipResponse {
    fn from(c: &responses::AddgossipResponse) -> Self {
        Self {
        }
    }
}

#[allow(unused_variables)]
impl From<&responses::AutocleaninvoiceResponse> for pb::AutocleaninvoiceResponse {
    fn from(c: &responses::AutocleaninvoiceResponse) -> Self {
        Self {
            enabled: c.enabled.clone(),
            expired_by: c.expired_by.clone(),
            cycle_seconds: c.cycle_seconds.clone(),
        }
    }
}

#[allow(unused_variables)]
impl From<&responses::CheckmessageResponse> for pb::CheckmessageResponse {
    fn from(c: &responses::CheckmessageResponse) -> Self {
        Self {
            verified: c.verified.clone(),
            pubkey: c.pubkey.as_ref().map(|v| hex::decode(&v).unwrap()),
        }
    }
}

#[allow(unused_variables)]
impl From<&responses::CloseResponse> for pb::CloseResponse {
    fn from(c: &responses::CloseResponse) -> Self {
        Self {
            item_type: c.item_type as i32,
            tx: c.tx.as_ref().map(|v| hex::decode(&v).unwrap()),
            txid: c.txid.as_ref().map(|v| hex::decode(&v).unwrap()),
        }
    }
}

